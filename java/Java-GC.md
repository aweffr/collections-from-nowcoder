# Java GC

<http://naotu.baidu.com/file/c461361d15b615588365d2165eaeabce?token=5d11d8e66bb214f5>

## JVM的内存模型

### 线程栈

#### 栈分为3个部分：基本类型变量，执行环境上下文，操作指令区(存放操作指令)

#### 方法参数在栈顶交叉

#### 每个线程都有独立的线程栈空间

#### 线程栈只存基本类型和对象地址

##### 栈内存4字节对齐，short变int

##### 对象地址4字节，引用堆空间

#### 方法中局部变量在线程栈空间内

##### 局部变量不会竞争，线程安全

##### 方法参数在栈顶交叉，不拷贝, 减少中间状态读取

#### 堆栈的大小通常在256Kb ~ 756Kb之间

### 堆

#### 堆中对象是对象类的额一个副本, 复制包含其父类的所有非静态属性

### 永久代(方法区)

#### 为了和<堆>区分开, 又名Non-heap

#### 类信息

#### 常量

#### 静态变量

#### 运行时常量池

##### 字面量

###### 文本字符串

###### 声明为final的常量值

##### 符号引用

###### 编译原理方面的概念

###### 类和接口的"全限定名"

###### 字段的名称和描述符

###### 方法的名称和描述符

##### 具有动态性, 并非全是预置入Class文件中常量池的内容

###### String类的intern方法

### 直接内存

#### 不是JVM运行时数据区的一部分

#### 也会被频繁地使用

#### NIO, 基于通道(Channel)与缓冲区(Buffer)的方式

#### 使用Native方法直接分配堆外内存

#### 通过Java堆中的"DirectByteBuffer"对象访问操作

#### 避免了Java堆和Native堆中来回复制数据

## JVM 参数

### -Xss 栈大小

### -Xms 堆初始大小

### -Xmx 堆最大大小

### -XX:+UseSerialGC 指定JVM在新生代用Serial Collector

## GC思想

### 引用计数法

#### 问题: 对象之间循环引用, 不被JVM采用

### 可达性分析算法

#### 从"GC Roots"出发

##### 栈中对象 (执行的上下文)

##### 方法区中的静态引用对象 (全局引用)

##### 方法区中的常量引用

##### 本地方法栈(Native)引用的对象

### 垃圾收集算法

#### 标记-清除

##### 最基础的方法

##### 效率: 标记和清除的效率都不高

##### 空间: 产生大量不连续的内存碎片

#### 复制算法

##### 一个大Eden空间和两个小Survivor空间

##### IBM研究: 98%的对象是朝生夕死的

##### 将Eden和Survior中的对象一次性复制到另一个Survior中

##### HotSpot默认 Eden: Survivor= 8 : 1

##### 如果某次收集后有超过10%的对象存活, 就找老年代进行分配担保

#### 标记-整理算法

##### 复制算法对老年代不适用(老年代复制多, 不浪费50%空间的话还要另找担保)

##### 让所有标记存活的对象都向一端移动

##### 然后直接清理边界以外的内存

### 分代收集算法

## 引用类型

### 存在多种引用类型的动机

#### 如何描述一些"食之无味, 弃之可惜"的对象

#### 缓存

### 强引用: 不会被GC

### 软引用: GC不会回收, 除非要发生内存溢出异常了

### 弱引用: 只能活到下次GC之前

### 虚引用

#### 最弱, 无法通过虚引用来取得一个对象的实例

#### 只会在被GC时收到一个系统通知

## 还有一次机会

### 如果对象的finalize()方法被重写过

### 并且还没有被JVM的调用过

### 就会被缓刑

#### 缓刑细节

#### 被扔进F-Queue, JVM自带的一个低优先级线程会去执行finalize()方法

#### 只保证执行, 不保证会执行完

#### 执行完后会发生小规模二次GC, 如果对象把自己的this挂给了类变量或者成员变量就逃脱

#### 不过最多只能逃一回, 因为finalize对一个对象只会最多执行一回

### finalize()方法是当年Java为了吸引C++程序员的, 正常写代码应该用try-finally

## HotSpot 实现

### 安全点

#### 主动式中断: 各个线程在字节码中会主动轮询一个地址

#### 当需要中断时, 就把这个地址设置为不可见, 线程遇到它就trap进JVM的异常处理句柄

### 安全区域

#### 线程进入Sleep之类的安全区域时, 会主动标识自己进入了Safe Region, 欢迎GC

### Young区

#### Eden区

#### Survivor区

### Old区

### 分代收集规则

#### 新对象在Eden区创建(如果非常大会直接进Old),  Eden区满了会出发一次 minorGC

#### 在Young区采用复制算法, Survivor放不下时会塞进Old区

#### 在Survivor熬过了15次(默认)Minor GC的也会塞进Old区

#### 当Old区满了, 或者Minor GC所需要的Old区预留的空间(这是个动态的经验值)不够了, 就Full GC

### 收集器(Collectors)

#### Serial(串行GC)收集器

##### 简单, 有效

#### ParNew(并行GC)收集器

##### 多线程, 默认有几个核心就几个线程

#### Parallel Scavenge(并行回收GC)收集器

##### 目标不同: 达到一个可控制的吞吐量

##### 吞吐量 = 运行用户代码的时间/(用户代码时间+垃圾收集时间)

##### 提供了两个参数来精确控制吞吐量

###### 1.最大垃圾收集器停顿时间 (-XX：MaxGCPauseMillis    大于0的毫秒数，停顿时间小了就要牺牲相应的吞吐量和新生代空间)

###### 2.设置吞吐量大小 (-XX：GCTimeRatio    大于0小于100的整数，默认99，也就是允许最大1%的垃圾回收时间)

#### Serial Old(串行GC)收集器

#### Parallel Old(并行GC)收集器

##### Parallel Scavenge的老年代版本

###### 注重吞吐量以及CPU资源敏感的场合适合 Parallel Sacavenge + Prarllel Old

#### CMS(并发GC)收集器

##### 获取最短回收停顿时间为目标

##### Concurrent Mark Sweep

##### 基于“标记-清除”算法

###### 四个步骤

####### 1.初始标记(CMS initial mark)

######## 需要"Stop the world"

######## 只是标记出GC ROOTS能直接关联到的对象，速度很快

####### 3. 重新标记(CMS remark)

######## 需要"Stop the world"

######## 修正并发标记期间用户程序继续运作导致的变动

####### 4. 并发清除(CMS concurrent sweep)

######## 可以和用户线程并发执行

####### 2. 并发标记(CMS concurrenr mark)

######## 并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。

######## 可以和用户线程并发执行

###### 缺点

####### CMS收集器对CPU资源非常敏感

######## CMS默认启动的回收线程数是：(CPU数量+3) / 4。

######### 当核心数大于4, 并发回收占用25%以下资源

######### 当核心数小于4, 对用户的影响就很大

####### CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full  GC的产生。

####### CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片, 导致Full GC

######## Full GC会进行内存整理，但是内存整理过程依旧会"Stop the world"

#### G1

##### 把堆分成很多个Region, 优先收集回收价值最大的Region, 避免全区域垃圾收集

##### 相比于CMS, 整理偏于"标记--整理"

##### "可预测的停顿",  明确在长度M的时间片段内, 垃圾收集不超过N秒
