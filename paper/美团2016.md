1.
```
以下代码输出什么?
int a = 1,b = 32;
printf("%d,%d",a<<b,1<<32);
```

在VS中试了一下, 是`1, 0`
然后试了一下把字面值`1`换成a  
```
int a = 1,b = 32 ;
printf("%d,%d",a<<b, a<<32);
```
输出`1,1`, 所以就是字面值的问题?

网上搜了一下:
```
c标准规定
左移操作 如果右边的数大于或等于左边操作数的位数 行为不确定
c语言标准版本c99
iso/iec 9899 1999 第84页最后一行
The integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.
```
所以第一题算是未定义行为。

5.
```
有9个球,其中一个的质量与其他的不同,有一个天平,通过最多几次可以找出那个质量不一样的球?
```

正解是3次。
```
2次称不出来,3次能称12个的
原题为： 
有十二个小球特征相同,其中只有一个质量异常,要求用一部没有砝码的天平称三次,将那个质量异常的球找出来. 

设标准小球质量为w,并代表任意一个正常小球,将12个小球依次编号为a1,a2,...,a12,分组为： 
a1,a2 ,a3 ,a4 为A1组 
a5,a6 ,a7 ,a8 为A2组 
a9,a10,a11,a12 为A3组 
==（第一次）1选定任意2组--取A1,A2进行比较,如果 
1 A1=A2 则A3组为异常球组 
重新分组为: 
B1:a9 a10 
B2:a11 w 
B3:a12 w 
====（第二次）取B2 B3 任意1组--B2 与 B1 进行比较,如果 
1.1 B1=B2 则 B1 B2 为正常组,B3(a12,w)为异常组,异常球为a12 
1.2 B1 != B2 B3(a12,w) 为正常组,以B1
```

6.
```
给字母重新进行二进制编码,以使得"MT-TECH-TEAM"(包含连字符,不包含引号)的长度最小.并能够根据编码,解码回原来的字符串.请问最优编码情况下该字串的长度是多少bit?
```
有7个数字，可以采用 _ _ _ 三位编码（0 - 6）或者 (1 - 7)， 共有12个字符。
3 * 12 => 36

错误。正解是用`哈夫曼树`.见同目录图。
此外， 有人说`根据信息熵，这个字符串的信息量为：27.588bit（也就是压缩的极限），就预估了33`。相关连接<http://www.ruanyifeng.com/blog/2014/09/information-entropy.html>

7.
```
以下哪个ip不和10.11.12.91/28处于同一个子网
10.11.12.85/28
10.11.12.88/28
10.11.12.94/28
10.11.12.97/28
```
IP前缀表示: 前缀表示/面数字掩码1前缀数
```
91 -> 0101 1011
      0101 0000 -> 80
      0101 1111 -> 95
```
因此应该选`10.11.12.97/28`


9.
```
开发C代码时,经常见到如下类型的结构体定义:
typedef struct list_t{
struct list_t *next;
struct list_t *prev;
char data[0];
}list_t;
请问在32位系统中,sizeof(list_t)的值为?
```
VS中实验得到的值是8

然后试验了一下
```
typedef struct list_t {
	struct list_t *next;
	struct list_t *prev;
	char data;
}list_t;
```
VS实验得到的值是12


本题的知识点  
**柔性数组**  
把单一元素的数组放在一个struct的尾端，使得每个struct对象可以拥有可变大小的数组。  
开始题目中的char data[0] 或写成char data[]，即为柔性数组;  
data不占用struct的空间，只是作为一个符号地址存在。 因此sizeof的值是两个指针所占字节，即4+4 = 8字节。  

```
Struct test{ 
     int a; 
     char c[0]; 
}Test;
char c[0]为长度为0的数组，是一个偏移量，不占空间。
如果没有额外的数据，则为结构体指针分配空间是  Test *p = (Test *)malloc(sizeof(Test));
如果有额外1024个字符数据要传递，则为结构体指针分配空间是 Test *p = (Test *)malloc(sizeof(Test)+1024*sizeof(char))；
所以如果定义结构体时，为了保证c数组能足够容纳下数据，定义了非常大的空间大小，如char c[1024],但在实际使用中，多数数据不能充分使用c[1024]的空间，导致内存产生大量的碎片。采用c[0]的定义方式，给了结构体足够的缓冲空间以根据实际数据的大小动态调整结构体指针指向内存地址的大小。
```

10.单选题
```
以下哪个属于在预编译阶段执行____,以下哪些指令属于操作符___
a:malloc;  b:++;  c:#pragma;  d:sizeof;   e:#define
```
答案是 预编译c,e 操作符b,d
**为什么？** //TODO

17题
```
C++中构造函数和析构函数可以抛出异常吗?
```
如下所示：
```
一.  析构函数
     参照《Effective C++》中条款08：别让异常逃离析构函数。
     1. 不要在析构函数中抛出异常！虽然C++并不禁止析构函数抛出异常，但这样会导致程序过早结束或出现不明确的行为。
     2. 如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
     3. 如果析构函数中异常非抛不可，那就用try catch来将异常吞下，但这样方法并不好，我们提倡有错早些报出来。
 
二.  构造函数
     1. 构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。
     2. 因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。
     3. 构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。（如何保证？？？使用auto_ptr？？？）
```

