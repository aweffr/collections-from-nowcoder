# 链表环路全家桶

## 两个单链表相交的一系列问题
本题中, 单链表可能有环, 也可能无环. 给定两个单链表的头结点 `head1` 和 `head2`, 这两个单链表可能相交, 也可能不相交.
要求实现一个函数, 如果两个链表相交, 请返回相交的第一个节点; 如果不相交, 则返回null;

**要求空间复杂度O(1)**

## 本问题可以福成三个子问题
1. 如何判断一个链表是否有环, 如果有, 则返回第一个进入环的节点, 没有则返回null
2. 如何判断两个**无环**链表是否相交, 相交则返回第一个相交节点, 不相交则返回null
3. 如何判断两个**有环**链表是否相交, 相交则返回第一个相交节点, 不相交则返回null
- *如果一个链表有环, 另一个链表无环, 那他们是不可能相交的, 直接返回null*

## 问题一: 判断一个链表是否有环
1. 设置一个慢指针一个快指针从head开始遍历链表
2. 如果无环, fast指针一定会先到终点
3. 如果有环, fast指针一定会和slow指针相遇
4. 当fast和slow相遇, 把fast移回head位置, 然后两个指针都只移动一步, 继续遍历, 再次相遇的节点就是第一个入环的节点.

我的证明:
![cycle-1.png](./cycle-1.png)
- 慢指针走过的距离 S<sub>slow</sub> = X + D
- 快指针走过的距离 S<sub>fast</sub> = 2 * (X + D)
- S<sub>fast</sub> - S<sub>slow</sub> = X + D
- 同时, S<sub>fast</sub> - S<sub>slow</sub> 等同于 **为了相遇而多跑的圈数** 即
- S<sub>fast</sub> - S<sub>slow</sub> = n * R (n = 1, 2, 3...)
- 得到 X = n * R - D

即两个指针的第二次相遇, 是一个指针回到原点在走X距离后, 另一个指针从相遇点正好走了n圈, 并回退D步所处的位置, 即环入口.
